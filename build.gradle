plugins {
    id 'java'
    id 'application'
    id 'org.gradle.test-retry' version '1.5.8'
    id 'com.github.ben-manes.versions' version '0.51.0'
    id 'org.owasp.dependencycheck' version '9.0.9'
}

// Project configuration
group = 'com.example'
version = '1.0.0'
description = 'Agent-Orange: Pentesting Chatbot with AI-driven analysis tools'

// Java compatibility
java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
    withSourcesJar()
    withJavadocJar()
}

// Application configuration
application {
    mainClass = 'com.example.Main'
    applicationDefaultJvmArgs = [
    // Memory configuration optimized for i7-7700T with 16-32GB RAM
    '-Xmx6g',                           // Reduced from 4g to leave room for ChromaDB/Ghidra
    '-Xms1g',                           // Conservative initial heap
    '-XX:+UseG1GC',                     // Low-latency garbage collector
    '-XX:MaxGCPauseMillis=200',         // Target max GC pause time
    '-XX:+UseStringDeduplication',      // Save memory on duplicate strings
    '-XX:+UnlockExperimentalVMOptions', // Enable experimental optimizations
    '-XX:G1HeapRegionSize=16m',         // Optimize for available cores
    '-XX:ConcGCThreads=2',              // Use 2 concurrent GC threads (50% of cores)
    '-XX:ParallelGCThreads=4',          // Use all 4 cores for parallel GC
    '-Djava.library.path=bin',
    // CPU-specific optimizations
    '-XX:+UseFastAccessorMethods',      // Faster field access
    '-XX:+OptimizeStringConcat',        // Optimize string operations
    // Ghidra configuration via system properties
    project.hasProperty('ghidra.home') ? "-Dghidra.home=${project.property('ghidra.home')}" : '',
    project.hasProperty('ghidra.headless.path') ? "-Dghidra.headless.path=${project.property('ghidra.headless.path')}" : '',
    project.hasProperty('ghidra.project.dir') ? "-Dghidra.project.dir=${project.property('ghidra.project.dir')}" : '',
    project.hasProperty('ghidra.project.name') ? "-Dghidra.project.name=${project.property('ghidra.project.name')}" : ''
].findAll { it != '' }  // Remove empty strings
}

// Repository configuration with security considerations
repositories {
    mavenCentral()
}

// Dependency version management
ext {
    versions = [
        gson: '2.10.1',
        junit: '4.13.2',
        hamcrest: '1.3',
        slf4j: '2.0.12',
        logback: '1.4.14',
        commonsLang: '3.14.0',
        commonsIo: '2.15.1',
        jacksonCore: '2.16.1'
    ]
}

dependencies {
    // Core dependencies
    implementation "com.google.code.gson:gson:${versions.gson}"
    implementation "org.apache.commons:commons-lang3:${versions.commonsLang}"
    implementation "commons-io:commons-io:${versions.commonsIo}"
    
    // Logging dependencies
    implementation "org.slf4j:slf4j-api:${versions.slf4j}"
    implementation "ch.qos.logback:logback-classic:${versions.logback}"
    
    // JSON processing (additional security)
    implementation "com.fasterxml.jackson.core:jackson-core:${versions.jacksonCore}"
    implementation "com.fasterxml.jackson.core:jackson-databind:${versions.jacksonCore}"
    
    // Test dependencies
    testImplementation "junit:junit:${versions.junit}"
    testImplementation "org.hamcrest:hamcrest-core:${versions.hamcrest}"
    testRuntimeOnly "org.junit.vintage:junit-vintage-engine:5.10.2"
}

// Source sets configuration
sourceSets {
    main {
        java {
            srcDirs = ['main']
            exclude '**/*Test.java'
            exclude 'TestMain.java'
            exclude 'ExtractFunctions.java'  // Ghidra script, not main application code
        }
        resources {
            srcDirs = ['src/main/resources']
        }
    }
    test {
        java {
            srcDirs = ['main']
            include '**/*Test.java'
            include 'TestMain.java'
        }
    }
}

// Compilation configuration
compileJava {
    options.encoding = 'UTF-8'
    options.compilerArgs += ['-Xlint:all', '-Xlint:-processing']
    options.deprecation = true
    options.warnings = true
}

compileTestJava {
    options.encoding = 'UTF-8'
    options.compilerArgs += ['-Xlint:all']
}

// JAR configuration for complete offline operation
jar {
    archiveFileName = 'chatbot.jar'
    destinationDirectory = file('bin')
    
    manifest {
        attributes(
            'Main-Class': 'com.example.Main',
            'Implementation-Title': project.name,
            'Implementation-Version': project.version + '-OFFLINE',
            'Built-By': System.getProperty('user.name'),
            'Built-Date': new Date().toString(),
            'Built-JDK': System.getProperty('java.version'),
            'Agent-Orange-Mode': 'STANDALONE-OFFLINE',
            'Bundle-Native-Libraries': 'true'
        )
    }
    
    // Include ALL runtime dependencies (fat JAR for offline use)
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    
    // Bundle native libraries directly in JAR
    from('bin') {
        into 'native-libs'
        include '*.so', '*.dll', '*.dylib'
    }
    
    // Bundle local embedding models
    from('models') {
        into 'models'
        include '**/*'
        exclude '*.tmp', '*.lock'
    }
    
    // Bundle Ghidra scripts and configurations
    from('main') {
        into 'ghidra-scripts'
        include 'ExtractFunctions.java'
    }
    
    // Bundle configuration files
    from('.') {
        into 'config'
        include 'application.properties'
        include 'offline-config.properties'
    }
    
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    
    // Exclude conflicting files for clean offline operation
    exclude 'META-INF/*.RSA', 'META-INF/*.SF', 'META-INF/*.DSA'
    exclude 'META-INF/LICENSE*'
    exclude 'META-INF/NOTICE*'
    exclude '**/module-info.class'
}

// Native library management
task copyNativeLibs(type: Copy) {
    description = 'Copy native libraries to bin directory'
    group = 'build'
    
    from configurations.runtimeClasspath.filter { 
        it.name.endsWith('.so') || it.name.endsWith('.dll') || it.name.endsWith('.dylib') 
    }
    into 'bin'
}

// Generate JNI header file
task generateJNIHeader(type: Exec) {
    description = 'Generate JNI header file'
    group = 'build'
    
    commandLine 'javac', '-h', 'main', '-cp', 'build/classes/java/main', 'main/LlamaJNI.java'
    
    dependsOn compileJava
    
    inputs.files 'main/LlamaJNI.java'
    outputs.files 'main/com_example_LlamaJNI.h'
    
    onlyIf {
        !file('main/com_example_LlamaJNI.h').exists() || 
        file('main/LlamaJNI.java').lastModified() > file('main/com_example_LlamaJNI.h').lastModified()
    }
}

// JNI compilation task
task compileJNI(type: Exec) {
    description = 'Compile JNI libraries for llama.cpp integration'
    group = 'build'
    
    dependsOn generateJNIHeader
    
    // Platform detection
    def osName = System.getProperty('os.name').toLowerCase()
    def isWindows = osName.contains('windows')
    def isMac = osName.contains('mac')
    def isLinux = osName.contains('linux')
    
    def javaHome = System.getProperty('java.home')
    def includePath = "$javaHome/include"
    def platformInclude = isWindows ? "$javaHome/include/win32" : 
                         isMac ? "$javaHome/include/darwin" : 
                         "$javaHome/include/linux"
    
    def outputLib = isWindows ? 'bin/llama.dll' : 
                   isMac ? 'bin/libllama.dylib' : 
                   'bin/libllama.so'
    
    // Ensure bin directory exists
    doFirst {
        file('bin').mkdirs()
    }
    
    // Compilation command with i7-7700T optimizations
    if (isWindows) {
        commandLine 'g++', '-shared', '-fPIC', '-O3',
                   '-march=skylake', '-mtune=skylake', '-mavx2', '-mfma',
                   '-pthread', '-flto', '-DNDEBUG',
                   "-I$includePath", "-I$platformInclude", '-Imain',
                   '-o', outputLib,
                   'main/llama_jni.cpp',
                   '-Wl,-O1', '-Wl,--strip-all'
    } else {
        commandLine 'g++', '-shared', '-fPIC', '-O3',
                   '-march=skylake', '-mtune=skylake', '-mavx2', '-mfma',
                   '-pthread', '-flto', '-DNDEBUG',
                   "-I$includePath", "-I$platformInclude", '-Imain',
                   '-o', outputLib,
                   'main/llama_jni.cpp',
                   '-Wl,-O1', '-Wl,--strip-all'
    }
    
    // Only run if source files are newer
    inputs.files 'main/llama_jni.cpp', 'main/LlamaJNI.h', 'main/com_example_LlamaJNI.h'
    outputs.file outputLib
    
    onlyIf {
        // Skip if GCC is not available
        def hasGcc = true
        try {
            def result = project.exec {
                commandLine 'g++', '--version'
                ignoreExitValue = true
            }
            hasGcc = result.exitValue == 0
        } catch (Exception e) {
            hasGcc = false
        }
        
        // Check if llama.cpp headers are available
        def hasLlama = file('main/llama.h').exists() || 
                      file('/usr/local/include/llama.h').exists() ||
                      file('/opt/llama.cpp/llama.h').exists()
        
        // Check if source file exists
        def hasSource = file('main/llama_jni.cpp').exists()
        
        // Check if JNI header exists
        def hasJNIHeader = file('main/com_example_LlamaJNI.h').exists()
        
        if (!hasGcc) {
            logger.warn("GCC/G++ not found. JNI compilation skipped.")
            logger.warn("Install with: sudo apt-get install build-essential")
        } else if (!hasLlama) {
            logger.warn("llama.cpp headers not found. JNI compilation skipped.")
            logger.warn("To enable JNI compilation:")
            logger.warn("1. Install llama.cpp: git clone https://github.com/ggerganov/llama.cpp.git")
            logger.warn("2. Build llama.cpp: cd llama.cpp && make")
            logger.warn("3. Copy llama.h to main/llama.h")
            logger.warn("4. Or run: ./setup_llama.sh --install-method source")
        } else if (!hasSource) {
            logger.warn("llama_jni.cpp source file not found in main/")
        } else if (!hasJNIHeader) {
            logger.warn("JNI header not generated. Run: ./gradlew generateJNIHeader")
        }
        
        // Check if rebuild is needed
        def needsRebuild = !file(outputLib).exists() || 
                          (hasSource && file('main/llama_jni.cpp').lastModified() > file(outputLib).lastModified())
        
        def shouldCompile = hasGcc && hasLlama && hasSource && hasJNIHeader && needsRebuild
        
        if (shouldCompile) {
            logger.info("JNI compilation conditions met - proceeding with compilation")
        }
        
        return shouldCompile
    }
}

// Test configuration
test {
    useJUnit()
    
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat "full"
    }
    
    // System properties for tests
    systemProperty 'java.library.path', 'bin'
    systemProperty 'java.awt.headless', 'true'
    
    // JVM arguments for tests - Optimized for i7-7700T
jvmArgs '-Xmx2g', '-Xms512m', '-XX:+UseG1GC', '-XX:MaxGCPauseMillis=100', '-XX:+UseStringDeduplication'
    
    // Retry failed tests
    retry {
        maxRetries = 2
        maxFailures = 3
    }
}

// Security and dependency checking
dependencyCheck {
    formats = ['HTML', 'XML', 'JSON']
    outputDirectory = 'build/reports/dependency-check'
    scanConfigurations = ['runtimeClasspath']
    
    // CVE data settings
    nvd {
        validForHours = 24
    }
    failBuildOnCVSS = 7.0
    
    // Suppression file for false positives
    suppressionFile = 'dependency-check-suppressions.xml'
}

// Dependency updates checking
dependencyUpdates {
    checkForGradleUpdate = true
    gradleReleaseChannel = 'current'
    
    resolutionStrategy {
        componentSelection { rules ->
            rules.all { ComponentSelection selection ->
                boolean rejected = ['alpha', 'beta', 'rc', 'cr', 'm', 'preview', 'b', 'ea'].any { qualifier ->
                    selection.candidate.version ==~ /(?i).*[.-]${qualifier}[.\d-+]*/
                }
                if (rejected) {
                    selection.reject('Release candidate')
                }
            }
        }
    }
}

// Offline build task for ThinkStation P320
task buildOffline {
    description = 'Build Agent-Orange for complete offline operation'
    group = 'distribution'
    
    dependsOn clean, compileJava, jar, copyNativeLibs
    
    doLast {
        println "✅ Agent-Orange built for offline operation"
        println "📁 JAR location: bin/chatbot.jar"
        println "🔧 Run: ./setup_offline.sh to configure offline mode"
        println "🚀 Run: ./run_offline.sh to start in offline mode"
    }
}

// Build task dependencies
build.dependsOn copyNativeLibs
jar.dependsOn compileJNI

// Clean task enhancement
clean {
    delete 'bin'
    delete 'logs'
    delete 'tmp'
    delete fileTree(dir: '.', include: '*.log')
}

// Distribution configuration
distributions {
    main {
        distributionBaseName = 'agent-orange'
        contents {
            from(jar)
            from('bin') {
                into 'bin'
                include '*.so', '*.dll', '*.dylib'
            }
            from('.') {
                include '*.sh', '*.properties', '*.md'
                exclude 'build.sh'
            }
            from('build/libs') {
                into 'lib'
            }
        }
    }
}

// Custom tasks for project management
task downloadDependencies {
    description = 'Download and verify all dependencies'
    group = 'build setup'
    
    doLast {
        println "Dependencies will be downloaded automatically on first build"
        println "Run './gradlew build' to download and compile everything"
    }
}

task listDependencies {
    description = 'List all project dependencies with versions'
    group = 'help'
    
    doLast {
        println "Project Dependencies:"
        configurations.runtimeClasspath.incoming.resolutionResult.allDependencies.each {
            if (it.hasProperty('selected')) {
                println "  ${it.selected.id}"
            }
        }
    }
}

task securityCheck {
    description = 'Run comprehensive security checks on dependencies'
    group = 'verification'
    dependsOn dependencyCheckAnalyze, dependencyUpdates
}

// Wrapper configuration for reproducible builds
wrapper {
    gradleVersion = '8.6'
    distributionType = Wrapper.DistributionType.BIN
}