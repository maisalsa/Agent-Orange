package com.example;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Represents a hierarchical tree structure for organizing vulnerabilities.
 * 
 * This class provides a comprehensive structure for organizing vulnerabilities
 * by target, service, and attack surface, enabling efficient querying,
 * analysis, and reporting of security findings.
 * 
 * @author Agent-Orange Team
 * @version 1.0
 */
public class VulnerabilityTree {
    private VulnerabilityNode root;
    
    /**
     * Constructs a new VulnerabilityTree.
     * 
     * @param projectName The name of the project this tree represents
     */
    public VulnerabilityTree(String projectName) {
        if (projectName == null || projectName.trim().isEmpty()) {
            throw new IllegalArgumentException("Project name cannot be null or empty");
        }
        this.root = new VulnerabilityNode(projectName.trim(), "PROJECT");
    }
    
    /**
     * Gets the root node of the tree.
     * 
     * @return The root node
     */
    public VulnerabilityNode getRoot() {
        return root;
    }
    
    /**
     * Adds a vulnerability to the tree at the appropriate location.
     * 
     * This method creates the necessary hierarchy (target -> service -> path)
     * and places the vulnerability at the correct location in the tree.
     * 
     * @param vulnerability The vulnerability to add
     */
    public void addVulnerability(Vulnerability vulnerability) {
        if (vulnerability == null) {
            throw new IllegalArgumentException("Vulnerability cannot be null");
        }
        
        // Find or create target node
        VulnerabilityNode targetNode = root.findOrCreateChild(vulnerability.getTarget(), "TARGET");
        
        // Find the appropriate node to attach the vulnerability
        VulnerabilityNode attachNode = targetNode;
        
        // If service is specified, create service node
        if (vulnerability.getService() != null && !vulnerability.getService().trim().isEmpty()) {
            attachNode = targetNode.findOrCreateChild(vulnerability.getService(), "SERVICE");
        }
        
        // If path is specified, create path node
        if (vulnerability.getPath() != null && !vulnerability.getPath().trim().isEmpty()) {
            attachNode = attachNode.findOrCreateChild(vulnerability.getPath(), "PATH");
        }
        
        // Add the vulnerability to the appropriate node
        attachNode.addVulnerability(vulnerability);
    }
    
    /**
     * Removes a vulnerability from the tree.
     * 
     * @param vulnerabilityId The ID of the vulnerability to remove
     * @return true if the vulnerability was found and removed, false otherwise
     */
    public boolean removeVulnerability(String vulnerabilityId) {
        if (vulnerabilityId == null || vulnerabilityId.trim().isEmpty()) {
            return false;
        }
        
        return removeVulnerabilityRecursive(root, vulnerabilityId.trim());
    }
    
    /**
     * Recursively searches for and removes a vulnerability by ID.
     * 
     * @param node The node to search from
     * @param vulnerabilityId The ID of the vulnerability to remove
     * @return true if the vulnerability was found and removed
     */
    private boolean removeVulnerabilityRecursive(VulnerabilityNode node, String vulnerabilityId) {
        // Check vulnerabilities in this node
        if (node.removeVulnerabilityById(vulnerabilityId)) {
            return true;
        }
        
        // Recursively check child nodes
        for (VulnerabilityNode child : node.getChildren()) {
            if (removeVulnerabilityRecursive(child, vulnerabilityId)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Finds a vulnerability by ID anywhere in the tree.
     * 
     * @param vulnerabilityId The ID of the vulnerability to find
     * @return The vulnerability if found, null otherwise
     */
    public Vulnerability findVulnerability(String vulnerabilityId) {
        if (vulnerabilityId == null || vulnerabilityId.trim().isEmpty()) {
            return null;
        }
        
        return findVulnerabilityRecursive(root, vulnerabilityId.trim());
    }
    
    /**
     * Recursively searches for a vulnerability by ID.
     * 
     * @param node The node to search from
     * @param vulnerabilityId The ID of the vulnerability to find
     * @return The vulnerability if found, null otherwise
     */
    private Vulnerability findVulnerabilityRecursive(VulnerabilityNode node, String vulnerabilityId) {
        // Check vulnerabilities in this node
        for (Vulnerability vuln : node.getVulnerabilities()) {
            if (vuln.getId().equals(vulnerabilityId)) {
                return vuln;
            }
        }
        
        // Recursively check child nodes
        for (VulnerabilityNode child : node.getChildren()) {
            Vulnerability found = findVulnerabilityRecursive(child, vulnerabilityId);
            if (found != null) {
                return found;
            }
        }
        
        return null;
    }
    
    /**
     * Gets all vulnerabilities in the tree.
     * 
     * @return A list of all vulnerabilities
     */
    public List<Vulnerability> getAllVulnerabilities() {
        return root.getAllVulnerabilities();
    }
    
    /**
     * Gets vulnerabilities for a specific target.
     * 
     * @param target The target to search for
     * @return A list of vulnerabilities for the specified target
     */
    public List<Vulnerability> getVulnerabilitiesForTarget(String target) {
        if (target == null || target.trim().isEmpty()) {
            return new ArrayList<>();
        }
        
        VulnerabilityNode targetNode = root.findChild(target.trim());
        if (targetNode == null) {
            return new ArrayList<>();
        }
        
        return targetNode.getAllVulnerabilities();
    }
    
    /**
     * Gets vulnerabilities for a specific service on a target.
     * 
     * @param target The target to search for
     * @param service The service to search for
     * @return A list of vulnerabilities for the specified service
     */
    public List<Vulnerability> getVulnerabilitiesForService(String target, String service) {
        if (target == null || target.trim().isEmpty() || 
            service == null || service.trim().isEmpty()) {
            return new ArrayList<>();
        }
        
        VulnerabilityNode targetNode = root.findChild(target.trim());
        if (targetNode == null) {
            return new ArrayList<>();
        }
        
        VulnerabilityNode serviceNode = targetNode.findChild(service.trim());
        if (serviceNode == null) {
            return new ArrayList<>();
        }
        
        return serviceNode.getAllVulnerabilities();
    }
    
    /**
     * Gets vulnerabilities by severity level.
     * 
     * @param severity The severity level to filter by
     * @return A list of vulnerabilities with the specified severity
     */
    public List<Vulnerability> getVulnerabilitiesBySeverity(Severity severity) {
        if (severity == null) {
            return new ArrayList<>();
        }
        
        return root.getVulnerabilitiesBySeverity(severity);
    }
    
    /**
     * Gets all targets in the tree.
     * 
     * @return A list of target names
     */
    public List<String> getTargets() {
        return root.getChildren().stream()
                .filter(child -> "TARGET".equals(child.getType()))
                .map(VulnerabilityNode::getName)
                .collect(Collectors.toList());
    }
    
    /**
     * Gets all services for a specific target.
     * 
     * @param target The target to get services for
     * @return A list of service names for the specified target
     */
    public List<String> getServicesForTarget(String target) {
        if (target == null || target.trim().isEmpty()) {
            return new ArrayList<>();
        }
        
        VulnerabilityNode targetNode = root.findChild(target.trim());
        if (targetNode == null) {
            return new ArrayList<>();
        }
        
        return targetNode.getChildren().stream()
                .filter(child -> "SERVICE".equals(child.getType()))
                .map(VulnerabilityNode::getName)
                .collect(Collectors.toList());
    }
    
    /**
     * Gets the total count of vulnerabilities in the tree.
     * 
     * @return The total vulnerability count
     */
    public int getTotalVulnerabilityCount() {
        return root.getTotalVulnerabilityCount();
    }
    
    /**
     * Gets vulnerability counts by severity for the entire tree.
     * 
     * @return A list of severity counts
     */
    public List<String> getSeverityCounts() {
        return root.getSeverityCounts();
    }
    
    /**
     * Checks if the tree is empty (contains no vulnerabilities).
     * 
     * @return true if the tree is empty, false otherwise
     */
    public boolean isEmpty() {
        return root.getTotalVulnerabilityCount() == 0;
    }
    
    /**
     * Creates a summary report of all vulnerabilities in the tree.
     * 
     * @return A formatted summary report
     */
    public String generateSummaryReport() {
        StringBuilder report = new StringBuilder();
        
        report.append("üõ°Ô∏è  Vulnerability Summary Report\n");
        report.append("=" .repeat(50)).append("\n");
        report.append("Project: ").append(root.getName()).append("\n");
        report.append("Total Vulnerabilities: ").append(getTotalVulnerabilityCount()).append("\n\n");
        
        // Severity breakdown
        List<String> severityCounts = getSeverityCounts();
        if (!severityCounts.isEmpty()) {
            report.append("üìä Severity Breakdown:\n");
            for (String count : severityCounts) {
                report.append("  ").append(count).append("\n");
            }
            report.append("\n");
        }
        
        // Target breakdown
        List<String> targets = getTargets();
        if (!targets.isEmpty()) {
            report.append("üéØ Targets:\n");
            for (String target : targets) {
                List<Vulnerability> targetVulns = getVulnerabilitiesForTarget(target);
                report.append("  ").append(target).append(" (").append(targetVulns.size()).append(" vulnerabilities)\n");
                
                // Group by severity for this target
                long critical = targetVulns.stream().filter(v -> v.getSeverity() == Severity.CRITICAL).count();
                long high = targetVulns.stream().filter(v -> v.getSeverity() == Severity.HIGH).count();
                long medium = targetVulns.stream().filter(v -> v.getSeverity() == Severity.MEDIUM).count();
                long low = targetVulns.stream().filter(v -> v.getSeverity() == Severity.LOW).count();
                long info = targetVulns.stream().filter(v -> v.getSeverity() == Severity.INFO).count();
                
                StringBuilder targetSummary = new StringBuilder("    ");
                if (critical > 0) targetSummary.append("üî¥").append(critical).append(" ");
                if (high > 0) targetSummary.append("üü†").append(high).append(" ");
                if (medium > 0) targetSummary.append("üü°").append(medium).append(" ");
                if (low > 0) targetSummary.append("üü¢").append(low).append(" ");
                if (info > 0) targetSummary.append("üîµ").append(info).append(" ");
                
                if (targetSummary.length() > 4) { // More than just the initial spaces
                    report.append(targetSummary.toString().trim()).append("\n");
                }
            }
            report.append("\n");
        }
        
        // Critical vulnerabilities list
        List<Vulnerability> criticalVulns = getVulnerabilitiesBySeverity(Severity.CRITICAL);
        if (!criticalVulns.isEmpty()) {
            report.append("üî¥ Critical Vulnerabilities (Immediate Action Required):\n");
            for (Vulnerability vuln : criticalVulns) {
                report.append("  ‚Ä¢ ").append(vuln.getName())
                      .append(" (").append(vuln.getFullPath()).append(")\n");
                if (vuln.getCveId() != null) {
                    report.append("    CVE: ").append(vuln.getCveId()).append("\n");
                }
            }
            report.append("\n");
        }
        
        // High vulnerabilities list
        List<Vulnerability> highVulns = getVulnerabilitiesBySeverity(Severity.HIGH);
        if (!highVulns.isEmpty()) {
            report.append("üü† High Vulnerabilities (High Priority):\n");
            for (Vulnerability vuln : highVulns) {
                report.append("  ‚Ä¢ ").append(vuln.getName())
                      .append(" (").append(vuln.getFullPath()).append(")\n");
            }
            report.append("\n");
        }
        
        return report.toString();
    }
    
    /**
     * Creates a detailed tree view of all vulnerabilities.
     * 
     * @param includeVulnerabilityDetails Whether to include vulnerability details in the tree
     * @return A formatted tree representation
     */
    public String formatTree(boolean includeVulnerabilityDetails) {
        if (isEmpty()) {
            return "üìÅ " + root.getName() + " (No vulnerabilities found)\n";
        }
        
        return root.formatTree(includeVulnerabilityDetails);
    }
    
    /**
     * Serializes the entire vulnerability tree to a string format.
     * 
     * @return The serialized tree data
     */
    public String serialize() {
        StringBuilder sb = new StringBuilder();
        sb.append("TREE_START\n");
        sb.append("project=").append(root.getName()).append("\n");
        sb.append("TREE_VULNERABILITIES\n");
        
        List<Vulnerability> allVulns = getAllVulnerabilities();
        for (Vulnerability vuln : allVulns) {
            sb.append(vuln.serialize());
        }
        
        sb.append("TREE_END\n");
        return sb.toString();
    }
    
    /**
     * Deserializes a vulnerability tree from string data.
     * 
     * @param data The serialized tree data
     * @return The deserialized VulnerabilityTree
     * @throws IllegalArgumentException if the data format is invalid
     */
    public static VulnerabilityTree deserialize(String data) {
        if (data == null || !data.contains("TREE_START") || !data.contains("TREE_END")) {
            throw new IllegalArgumentException("Invalid tree data format");
        }
        
        String[] lines = data.split("\n");
        String projectName = null;
        List<String> vulnData = new ArrayList<>();
        
        boolean inVulnSection = false;
        StringBuilder currentVuln = new StringBuilder();
        
        for (String line : lines) {
            if (line.trim().isEmpty()) continue;
            
            if (line.equals("TREE_START")) {
                continue;
            } else if (line.equals("TREE_VULNERABILITIES")) {
                inVulnSection = true;
                continue;
            } else if (line.equals("TREE_END")) {
                if (currentVuln.length() > 0) {
                    vulnData.add(currentVuln.toString());
                }
                break;
            }
            
            if (!inVulnSection) {
                if (line.startsWith("project=")) {
                    projectName = line.substring(8).trim();
                }
            } else {
                if (line.equals("VULN_START")) {
                    if (currentVuln.length() > 0) {
                        vulnData.add(currentVuln.toString());
                    }
                    currentVuln = new StringBuilder();
                }
                currentVuln.append(line).append("\n");
            }
        }
        
        if (projectName == null) {
            throw new IllegalArgumentException("Missing project name in tree data");
        }
        
        VulnerabilityTree tree = new VulnerabilityTree(projectName);
        
        // Deserialize and add all vulnerabilities
        for (String vulnStr : vulnData) {
            try {
                Vulnerability vuln = Vulnerability.deserialize(vulnStr);
                tree.addVulnerability(vuln);
            } catch (Exception e) {
                System.err.println("Warning: Failed to deserialize vulnerability: " + e.getMessage());
            }
        }
        
        return tree;
    }
    
    @Override
    public String toString() {
        return String.format("VulnerabilityTree{project='%s', vulnerabilities=%d, targets=%d}", 
                           root.getName(), getTotalVulnerabilityCount(), getTargets().size());
    }
}