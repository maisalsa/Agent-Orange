package com.example;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.lang.ref.WeakReference;
import java.util.stream.Collectors;

/**
 * Memory and performance optimized VulnerabilityTree for resource-constrained systems.
 * 
 * Key optimizations:
 * - Uses efficient hash-based indexing for fast lookups
 * - Implements lazy loading and weak reference caching
 * - Minimizes object creation through pooling
 * - Uses concurrent data structures for thread safety
 * - Provides memory compaction capabilities
 * - Optimizes tree traversal with indexed access
 * 
 * @author Agent-Orange Team
 * @version 2.0
 */
public class OptimizedVulnerabilityTree {
    
    // Core tree structure
    private final OptimizedVulnerabilityNode root;
    
    // Fast lookup indices for performance
    private final Map<String, Set<Vulnerability>> targetIndex;
    private final Map<String, Set<Vulnerability>> serviceIndex;
    private final Map<Severity, Set<Vulnerability>> severityIndex;
    private final Map<String, Vulnerability> cveIndex;
    
    // Cached collections with weak references
    private transient WeakReference<List<Vulnerability>> allVulnerabilitiesCache;
    private transient WeakReference<Map<String, Object>> statsCache;
    
    // Performance tracking
    private final AtomicInteger modificationCount = new AtomicInteger(0);
    private volatile long lastCacheUpdate = 0;
    private static final long CACHE_TTL_MS = 30000; // 30 seconds
    
    // Memory optimization settings
    private static final int INITIAL_INDEX_CAPACITY = 16;
    private static final float LOAD_FACTOR = 0.75f;
    
    /**
     * Constructs a new optimized VulnerabilityTree.
     * 
     * @param projectName The name of the project this tree represents
     */
    public OptimizedVulnerabilityTree(String projectName) {
        if (projectName == null || projectName.trim().isEmpty()) {
            throw new IllegalArgumentException("Project name cannot be null or empty");
        }
        
        this.root = new OptimizedVulnerabilityNode(projectName.trim().intern(), "PROJECT");
        
        // Initialize indices with concurrent access support
        this.targetIndex = new ConcurrentHashMap<>(INITIAL_INDEX_CAPACITY, LOAD_FACTOR);
        this.serviceIndex = new ConcurrentHashMap<>(INITIAL_INDEX_CAPACITY, LOAD_FACTOR);
        this.severityIndex = new ConcurrentHashMap<>(Severity.values().length, LOAD_FACTOR);
        this.cveIndex = new ConcurrentHashMap<>(INITIAL_INDEX_CAPACITY, LOAD_FACTOR);
        
        // Pre-populate severity index with empty sets
        for (Severity severity : Severity.values()) {
            this.severityIndex.put(severity, ConcurrentHashMap.newKeySet());
        }
    }
    
    /**
     * Copy constructor for creating optimized tree from legacy tree.
     * 
     * @param legacyTree The original vulnerability tree to optimize
     */
    public OptimizedVulnerabilityTree(VulnerabilityTree legacyTree) {
        this(legacyTree.getRoot().getName());
        
        // Copy all vulnerabilities efficiently
        List<Vulnerability> legacyVulns = legacyTree.getAllVulnerabilities();
        legacyVulns.forEach(this::addVulnerability);
    }
    
    /**
     * Adds a vulnerability to the tree with optimized indexing.
     * 
     * This method creates the necessary hierarchy and updates all indices
     * for fast retrieval operations.
     * 
     * @param vulnerability The vulnerability to add
     */
    public void addVulnerability(Vulnerability vulnerability) {
        if (vulnerability == null) {
            return;
        }
        
        // Add to tree structure
        addVulnerabilityToTree(vulnerability);
        
        // Update indices for fast lookups
        updateIndices(vulnerability, true);
        
        // Invalidate caches
        invalidateCache();
        modificationCount.incrementAndGet();
    }
    
    /**
     * Adds vulnerability to the tree hierarchy efficiently.
     */
    private void addVulnerabilityToTree(Vulnerability vulnerability) {
        String target = vulnerability.getTarget().intern();
        String service = vulnerability.getService();
        String path = vulnerability.getPath();
        
        // Find or create target node
        OptimizedVulnerabilityNode targetNode = root.findOrCreateChild(target, "TARGET");
        
        // Find or create service node if service is specified
        OptimizedVulnerabilityNode serviceNode = targetNode;
        if (service != null && !service.trim().isEmpty()) {
            serviceNode = targetNode.findOrCreateChild(service.trim().intern(), "SERVICE");
        }
        
        // Find or create path node if path is specified
        OptimizedVulnerabilityNode pathNode = serviceNode;
        if (path != null && !path.trim().isEmpty()) {
            pathNode = serviceNode.findOrCreateChild(path.trim().intern(), "PATH");
        }
        
        // Add vulnerability to the appropriate node
        pathNode.addVulnerability(vulnerability);
    }
    
    /**
     * Updates all indices for fast lookup operations.
     */
    private void updateIndices(Vulnerability vulnerability, boolean add) {
        String target = vulnerability.getTarget().intern();
        String service = vulnerability.getService();
        Severity severity = vulnerability.getSeverity();
        String cveId = vulnerability.getCveId();
        
        if (add) {
            // Add to indices
            targetIndex.computeIfAbsent(target, k -> ConcurrentHashMap.newKeySet()).add(vulnerability);
            
            if (service != null && !service.trim().isEmpty()) {
                serviceIndex.computeIfAbsent(service.intern(), k -> ConcurrentHashMap.newKeySet()).add(vulnerability);
            }
            
            severityIndex.get(severity).add(vulnerability);
            
            if (cveId != null && !cveId.trim().isEmpty()) {
                cveIndex.put(cveId.intern(), vulnerability);
            }
        } else {
            // Remove from indices
            Set<Vulnerability> targetSet = targetIndex.get(target);
            if (targetSet != null) {
                targetSet.remove(vulnerability);
                if (targetSet.isEmpty()) {
                    targetIndex.remove(target);
                }
            }
            
            if (service != null && !service.trim().isEmpty()) {
                Set<Vulnerability> serviceSet = serviceIndex.get(service.intern());
                if (serviceSet != null) {
                    serviceSet.remove(vulnerability);
                    if (serviceSet.isEmpty()) {
                        serviceIndex.remove(service.intern());
                    }
                }
            }
            
            severityIndex.get(severity).remove(vulnerability);
            
            if (cveId != null && !cveId.trim().isEmpty()) {
                cveIndex.remove(cveId.intern());
            }
        }
    }
    
    /**
     * Removes a vulnerability from the tree with index updates.
     * 
     * @param vulnerability The vulnerability to remove
     * @return true if the vulnerability was removed
     */
    public boolean removeVulnerability(Vulnerability vulnerability) {
        if (vulnerability == null) {
            return false;
        }
        
        boolean removed = removeVulnerabilityFromTree(vulnerability);
        if (removed) {
            updateIndices(vulnerability, false);
            invalidateCache();
            modificationCount.incrementAndGet();
        }
        
        return removed;
    }
    
    /**
     * Removes vulnerability from tree structure.
     */
    private boolean removeVulnerabilityFromTree(Vulnerability vulnerability) {
        String target = vulnerability.getTarget().intern();
        String service = vulnerability.getService();
        String path = vulnerability.getPath();
        
        OptimizedVulnerabilityNode targetNode = root.findChild(target);
        if (targetNode == null) {
            return false;
        }
        
        OptimizedVulnerabilityNode serviceNode = targetNode;
        if (service != null && !service.trim().isEmpty()) {
            serviceNode = targetNode.findChild(service.trim().intern());
            if (serviceNode == null) {
                return false;
            }
        }
        
        OptimizedVulnerabilityNode pathNode = serviceNode;
        if (path != null && !path.trim().isEmpty()) {
            pathNode = serviceNode.findChild(path.trim().intern());
            if (pathNode == null) {
                return false;
            }
        }
        
        return pathNode.removeVulnerability(vulnerability);
    }
    
    /**
     * Gets all vulnerabilities with caching for performance.
     * 
     * @return List of all vulnerabilities
     */
    public List<Vulnerability> getAllVulnerabilities() {
        long currentTime = System.currentTimeMillis();
        
        // Check cache validity
        if (allVulnerabilitiesCache != null && currentTime - lastCacheUpdate < CACHE_TTL_MS) {
            List<Vulnerability> cached = allVulnerabilitiesCache.get();
            if (cached != null) {
                return new ArrayList<>(cached); // Return defensive copy
            }
        }
        
        // Rebuild cache from tree traversal
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        collectVulnerabilities(root, vulnerabilities);
        
        this.allVulnerabilitiesCache = new WeakReference<>(new ArrayList<>(vulnerabilities));
        this.lastCacheUpdate = currentTime;
        
        return vulnerabilities;
    }
    
    /**
     * Recursively collects vulnerabilities from tree nodes.
     */
    private void collectVulnerabilities(OptimizedVulnerabilityNode node, List<Vulnerability> collector) {
        collector.addAll(node.getVulnerabilities());
        for (OptimizedVulnerabilityNode child : node.getChildren()) {
            collectVulnerabilities(child, collector);
        }
    }
    
    /**
     * Gets vulnerabilities for a specific target using index for fast lookup.
     * 
     * @param target The target to filter by
     * @return List of vulnerabilities for the target
     */
    public List<Vulnerability> getVulnerabilitiesForTarget(String target) {
        if (target == null) {
            return Collections.emptyList();
        }
        
        Set<Vulnerability> targetVulns = targetIndex.get(target.intern());
        return targetVulns != null ? new ArrayList<>(targetVulns) : Collections.emptyList();
    }
    
    /**
     * Gets vulnerabilities for a specific service using index.
     * 
     * @param service The service to filter by
     * @return List of vulnerabilities for the service
     */
    public List<Vulnerability> getVulnerabilitiesForService(String service) {
        if (service == null) {
            return Collections.emptyList();
        }
        
        Set<Vulnerability> serviceVulns = serviceIndex.get(service.intern());
        return serviceVulns != null ? new ArrayList<>(serviceVulns) : Collections.emptyList();
    }
    
    /**
     * Gets vulnerabilities by severity using index.
     * 
     * @param severity The severity level
     * @return List of vulnerabilities with the specified severity
     */
    public List<Vulnerability> getVulnerabilitiesBySeverity(Severity severity) {
        if (severity == null) {
            return Collections.emptyList();
        }
        
        Set<Vulnerability> severityVulns = severityIndex.get(severity);
        return severityVulns != null ? new ArrayList<>(severityVulns) : Collections.emptyList();
    }
    
    /**
     * Gets vulnerability by CVE ID using index for instant lookup.
     * 
     * @param cveId The CVE identifier
     * @return The vulnerability with the specified CVE ID, or null if not found
     */
    public Vulnerability getVulnerabilityByCveId(String cveId) {
        if (cveId == null) {
            return null;
        }
        return cveIndex.get(cveId.intern());
    }
    
    /**
     * Gets vulnerabilities by multiple criteria efficiently.
     * 
     * @param target Optional target filter
     * @param service Optional service filter
     * @param severity Optional severity filter
     * @return List of vulnerabilities matching all specified criteria
     */
    public List<Vulnerability> getVulnerabilities(String target, String service, Severity severity) {
        // Start with the most restrictive filter
        List<Vulnerability> candidates = null;
        
        if (target != null) {
            candidates = getVulnerabilitiesForTarget(target);
            if (candidates.isEmpty()) {
                return Collections.emptyList();
            }
        }
        
        if (service != null) {
            List<Vulnerability> serviceVulns = getVulnerabilitiesForService(service);
            if (serviceVulns.isEmpty()) {
                return Collections.emptyList();
            }
            
            if (candidates != null) {
                candidates = candidates.stream()
                    .filter(serviceVulns::contains)
                    .collect(Collectors.toList());
            } else {
                candidates = serviceVulns;
            }
        }
        
        if (severity != null) {
            List<Vulnerability> severityVulns = getVulnerabilitiesBySeverity(severity);
            if (severityVulns.isEmpty()) {
                return Collections.emptyList();
            }
            
            if (candidates != null) {
                candidates = candidates.stream()
                    .filter(severityVulns::contains)
                    .collect(Collectors.toList());
            } else {
                candidates = severityVulns;
            }
        }
        
        return candidates != null ? candidates : getAllVulnerabilities();
    }
    
    /**
     * Gets tree statistics with caching.
     * 
     * @return Map containing tree statistics
     */
    public Map<String, Object> getStatistics() {
        long currentTime = System.currentTimeMillis();
        
        // Check cache validity
        if (statsCache != null && currentTime - lastCacheUpdate < CACHE_TTL_MS) {
            Map<String, Object> cached = statsCache.get();
            if (cached != null) {
                return new HashMap<>(cached);
            }
        }
        
        // Calculate statistics
        Map<String, Object> stats = calculateStatistics();
        this.statsCache = new WeakReference<>(new HashMap<>(stats));
        
        return stats;
    }
    
    /**
     * Calculates tree statistics efficiently using indices.
     */
    private Map<String, Object> calculateStatistics() {
        Map<String, Object> stats = new HashMap<>();
        
        stats.put("targetCount", targetIndex.size());
        stats.put("serviceCount", serviceIndex.size());
        stats.put("cveCount", cveIndex.size());
        stats.put("modificationCount", modificationCount.get());
        
        // Severity distribution
        Map<Severity, Integer> severityDist = new EnumMap<>(Severity.class);
        for (Map.Entry<Severity, Set<Vulnerability>> entry : severityIndex.entrySet()) {
            severityDist.put(entry.getKey(), entry.getValue().size());
        }
        stats.put("severityDistribution", severityDist);
        
        // Total vulnerability count
        int totalVulns = severityDist.values().stream().mapToInt(Integer::intValue).sum();
        stats.put("totalVulnerabilities", totalVulns);
        
        return stats;
    }
    
    /**
     * Gets memory usage statistics for monitoring.
     * 
     * @return Map containing memory usage information
     */
    public Map<String, Object> getMemoryStats() {
        Map<String, Object> stats = new HashMap<>();
        
        stats.put("targetIndexSize", targetIndex.size());
        stats.put("serviceIndexSize", serviceIndex.size());
        stats.put("severityIndexSize", severityIndex.size());
        stats.put("cveIndexSize", cveIndex.size());
        stats.put("hasAllVulnsCache", allVulnerabilitiesCache != null && allVulnerabilitiesCache.get() != null);
        stats.put("hasStatsCache", statsCache != null && statsCache.get() != null);
        stats.put("modificationCount", modificationCount.get());
        
        // Calculate approximate memory usage
        int approximateVulnCount = severityIndex.values().stream()
            .mapToInt(Set::size)
            .sum();
        stats.put("approximateVulnerabilityCount", approximateVulnCount);
        
        return stats;
    }
    
    /**
     * Optimizes memory usage by cleaning up indices and caches.
     * Call this method during low-activity periods.
     */
    public void optimizeMemory() {
        // Clean up empty index entries
        targetIndex.entrySet().removeIf(entry -> entry.getValue().isEmpty());
        serviceIndex.entrySet().removeIf(entry -> entry.getValue().isEmpty());
        
        // Clear caches to free memory
        invalidateCache();
        
        // Optimize tree structure
        optimizeTreeStructure(root);
        
        // Suggest garbage collection
        System.gc();
    }
    
    /**
     * Recursively optimizes tree structure by removing empty nodes.
     */
    private void optimizeTreeStructure(OptimizedVulnerabilityNode node) {
        List<OptimizedVulnerabilityNode> children = new ArrayList<>(node.getChildren());
        for (OptimizedVulnerabilityNode child : children) {
            optimizeTreeStructure(child);
            
            // Remove empty leaf nodes (except root)
            if (child != root && child.getVulnerabilities().isEmpty() && child.getChildren().isEmpty()) {
                node.removeChild(child);
            }
        }
    }
    
    /**
     * Invalidates all cached data.
     */
    private void invalidateCache() {
        this.allVulnerabilitiesCache = null;
        this.statsCache = null;
        this.lastCacheUpdate = 0;
    }
    
    /**
     * Searches for vulnerabilities by name or description.
     * 
     * @param searchTerm The search term
     * @param caseSensitive Whether the search should be case sensitive
     * @return List of matching vulnerabilities
     */
    public List<Vulnerability> searchVulnerabilities(String searchTerm, boolean caseSensitive) {
        if (searchTerm == null || searchTerm.trim().isEmpty()) {
            return Collections.emptyList();
        }
        
        String term = caseSensitive ? searchTerm.trim() : searchTerm.trim().toLowerCase();
        
        return getAllVulnerabilities().stream()
            .filter(vuln -> matchesSearchTerm(vuln, term, caseSensitive))
            .collect(Collectors.toList());
    }
    
    /**
     * Checks if a vulnerability matches the search term.
     */
    private boolean matchesSearchTerm(Vulnerability vuln, String term, boolean caseSensitive) {
        if (vuln == null) return false;
        
        // Check CVE ID
        if (vuln.getCveId() != null) {
            String cveId = caseSensitive ? vuln.getCveId() : vuln.getCveId().toLowerCase();
            if (cveId.contains(term)) return true;
        }
        
        // Check name
        if (vuln.getName() != null) {
            String name = caseSensitive ? vuln.getName() : vuln.getName().toLowerCase();
            if (name.contains(term)) return true;
        }
        
        // Check description
        if (vuln.getDescription() != null) {
            String desc = caseSensitive ? vuln.getDescription() : vuln.getDescription().toLowerCase();
            if (desc.contains(term)) return true;
        }
        
        return false;
    }
    
    /**
     * Gets the root node of the tree.
     * 
     * @return The root node
     */
    public OptimizedVulnerabilityNode getRoot() {
        return root;
    }
    
    /**
     * Gets the total number of vulnerabilities efficiently.
     * 
     * @return Total vulnerability count
     */
    public int getTotalVulnerabilityCount() {
        return severityIndex.values().stream()
            .mapToInt(Set::size)
            .sum();
    }
    
    /**
     * Checks if the tree is empty.
     * 
     * @return true if no vulnerabilities are present
     */
    public boolean isEmpty() {
        return getTotalVulnerabilityCount() == 0;
    }
    
    /**
     * Gets all unique targets.
     * 
     * @return Set of target names
     */
    public Set<String> getAllTargets() {
        return Collections.unmodifiableSet(targetIndex.keySet());
    }
    
    /**
     * Gets all unique services.
     * 
     * @return Set of service names
     */
    public Set<String> getAllServices() {
        return Collections.unmodifiableSet(serviceIndex.keySet());
    }
    
    /**
     * Gets all CVE IDs present in the tree.
     * 
     * @return Set of CVE identifiers
     */
    public Set<String> getAllCveIds() {
        return Collections.unmodifiableSet(cveIndex.keySet());
    }
    
    @Override
    public String toString() {
        return String.format("OptimizedVulnerabilityTree{targets=%d, services=%d, vulnerabilities=%d, cves=%d}", 
                           targetIndex.size(), serviceIndex.size(), getTotalVulnerabilityCount(), cveIndex.size());
    }
}