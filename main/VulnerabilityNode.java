package com.example;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Represents a node in the vulnerability tree structure.
 * 
 * This class provides a hierarchical organization of vulnerabilities by target,
 * service, and attack surface, allowing for structured analysis and reporting.
 * 
 * @author Agent-Orange Team
 * @version 1.0
 */
public class VulnerabilityNode {
    private String name;
    private String type; // "TARGET", "SERVICE", "PATH", "VULNERABILITY"
    private List<VulnerabilityNode> children;
    private List<Vulnerability> vulnerabilities;
    private VulnerabilityNode parent;
    
    /**
     * Constructs a new VulnerabilityNode.
     * 
     * @param name The name or identifier for this node
     * @param type The type of node ("TARGET", "SERVICE", "PATH", "VULNERABILITY")
     */
    public VulnerabilityNode(String name, String type) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Node name cannot be null or empty");
        }
        if (type == null || type.trim().isEmpty()) {
            throw new IllegalArgumentException("Node type cannot be null or empty");
        }
        
        this.name = name.trim();
        this.type = type.trim().toUpperCase();
        this.children = new ArrayList<>();
        this.vulnerabilities = new ArrayList<>();
        this.parent = null;
    }
    
    /**
     * Gets the name of this node.
     * 
     * @return The node name
     */
    public String getName() {
        return name;
    }
    
    /**
     * Sets the name of this node.
     * 
     * @param name The new node name
     * @throws IllegalArgumentException if name is null or empty
     */
    public void setName(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Node name cannot be null or empty");
        }
        this.name = name.trim();
    }
    
    /**
     * Gets the type of this node.
     * 
     * @return The node type
     */
    public String getType() {
        return type;
    }
    
    /**
     * Sets the type of this node.
     * 
     * @param type The new node type
     * @throws IllegalArgumentException if type is null or empty
     */
    public void setType(String type) {
        if (type == null || type.trim().isEmpty()) {
            throw new IllegalArgumentException("Node type cannot be null or empty");
        }
        this.type = type.trim().toUpperCase();
    }
    
    /**
     * Gets the list of child nodes.
     * 
     * @return An unmodifiable list of child nodes
     */
    public List<VulnerabilityNode> getChildren() {
        return Collections.unmodifiableList(children);
    }
    
    /**
     * Gets the list of vulnerabilities directly associated with this node.
     * 
     * @return An unmodifiable list of vulnerabilities
     */
    public List<Vulnerability> getVulnerabilities() {
        return Collections.unmodifiableList(vulnerabilities);
    }
    
    /**
     * Gets the parent node of this node.
     * 
     * @return The parent node or null if this is a root node
     */
    public VulnerabilityNode getParent() {
        return parent;
    }
    
    /**
     * Sets the parent node of this node.
     * 
     * @param parent The parent node
     */
    protected void setParent(VulnerabilityNode parent) {
        this.parent = parent;
    }
    
    /**
     * Adds a child node to this node.
     * 
     * @param child The child node to add
     * @throws IllegalArgumentException if child is null or already has a parent
     */
    public void addChild(VulnerabilityNode child) {
        if (child == null) {
            throw new IllegalArgumentException("Child node cannot be null");
        }
        if (child.getParent() != null) {
            throw new IllegalArgumentException("Child node already has a parent");
        }
        if (children.contains(child)) {
            return; // Already added
        }
        
        children.add(child);
        child.setParent(this);
        
        // Sort children by name for consistent ordering
        children.sort(Comparator.comparing(VulnerabilityNode::getName));
    }
    
    /**
     * Removes a child node from this node.
     * 
     * @param child The child node to remove
     * @return true if the child was removed, false if it wasn't found
     */
    public boolean removeChild(VulnerabilityNode child) {
        if (child == null) {
            return false;
        }
        
        boolean removed = children.remove(child);
        if (removed) {
            child.setParent(null);
        }
        
        return removed;
    }
    
    /**
     * Finds a child node by name.
     * 
     * @param name The name of the child to find
     * @return The child node or null if not found
     */
    public VulnerabilityNode findChild(String name) {
        if (name == null || name.trim().isEmpty()) {
            return null;
        }
        
        String searchName = name.trim();
        return children.stream()
                .filter(child -> child.getName().equals(searchName))
                .findFirst()
                .orElse(null);
    }
    
    /**
     * Finds or creates a child node with the given name and type.
     * 
     * @param name The name of the child
     * @param type The type of the child
     * @return The existing or newly created child node
     */
    public VulnerabilityNode findOrCreateChild(String name, String type) {
        VulnerabilityNode existing = findChild(name);
        if (existing != null) {
            return existing;
        }
        
        VulnerabilityNode newChild = new VulnerabilityNode(name, type);
        addChild(newChild);
        return newChild;
    }
    
    /**
     * Adds a vulnerability to this node.
     * 
     * @param vulnerability The vulnerability to add
     * @throws IllegalArgumentException if vulnerability is null
     */
    public void addVulnerability(Vulnerability vulnerability) {
        if (vulnerability == null) {
            throw new IllegalArgumentException("Vulnerability cannot be null");
        }
        if (!vulnerabilities.contains(vulnerability)) {
            vulnerabilities.add(vulnerability);
            
            // Sort vulnerabilities by severity (critical first) then by name
            vulnerabilities.sort((v1, v2) -> {
                int severityCompare = Integer.compare(v2.getSeverity().getPriority(), 
                                                    v1.getSeverity().getPriority());
                if (severityCompare != 0) {
                    return severityCompare;
                }
                return v1.getName().compareTo(v2.getName());
            });
        }
    }
    
    /**
     * Removes a vulnerability from this node.
     * 
     * @param vulnerability The vulnerability to remove
     * @return true if the vulnerability was removed, false if it wasn't found
     */
    public boolean removeVulnerability(Vulnerability vulnerability) {
        return vulnerabilities.remove(vulnerability);
    }
    
    /**
     * Removes a vulnerability by ID from this node.
     * 
     * @param vulnerabilityId The ID of the vulnerability to remove
     * @return true if the vulnerability was removed, false if it wasn't found
     */
    public boolean removeVulnerabilityById(String vulnerabilityId) {
        return vulnerabilities.removeIf(v -> v.getId().equals(vulnerabilityId));
    }
    
    /**
     * Gets all vulnerabilities in this node and all descendant nodes.
     * 
     * @return A list of all vulnerabilities in this subtree
     */
    public List<Vulnerability> getAllVulnerabilities() {
        List<Vulnerability> allVulns = new ArrayList<>(vulnerabilities);
        
        for (VulnerabilityNode child : children) {
            allVulns.addAll(child.getAllVulnerabilities());
        }
        
        return allVulns;
    }
    
    /**
     * Gets the total count of vulnerabilities in this node and all descendant nodes.
     * 
     * @return The total vulnerability count
     */
    public int getTotalVulnerabilityCount() {
        int count = vulnerabilities.size();
        for (VulnerabilityNode child : children) {
            count += child.getTotalVulnerabilityCount();
        }
        return count;
    }
    
    /**
     * Gets vulnerability counts by severity for this node and all descendant nodes.
     * 
     * @return A list of severity counts in the format "🔴 Critical: 2"
     */
    public List<String> getSeverityCounts() {
        List<Vulnerability> allVulns = getAllVulnerabilities();
        
        int critical = 0, high = 0, medium = 0, low = 0, info = 0;
        
        for (Vulnerability vuln : allVulns) {
            switch (vuln.getSeverity()) {
                case CRITICAL: critical++; break;
                case HIGH: high++; break;
                case MEDIUM: medium++; break;
                case LOW: low++; break;
                case INFO: info++; break;
            }
        }
        
        List<String> counts = new ArrayList<>();
        if (critical > 0) counts.add("🔴 Critical: " + critical);
        if (high > 0) counts.add("🟠 High: " + high);
        if (medium > 0) counts.add("🟡 Medium: " + medium);
        if (low > 0) counts.add("🟢 Low: " + low);
        if (info > 0) counts.add("🔵 Info: " + info);
        
        return counts;
    }
    
    /**
     * Gets vulnerabilities filtered by severity.
     * 
     * @param severity The severity to filter by
     * @return A list of vulnerabilities with the specified severity
     */
    public List<Vulnerability> getVulnerabilitiesBySeverity(Severity severity) {
        return getAllVulnerabilities().stream()
                .filter(v -> v.getSeverity() == severity)
                .collect(Collectors.toList());
    }
    
    /**
     * Checks if this node is empty (no vulnerabilities and no children with vulnerabilities).
     * 
     * @return true if this node is empty, false otherwise
     */
    public boolean isEmpty() {
        if (!vulnerabilities.isEmpty()) {
            return false;
        }
        
        for (VulnerabilityNode child : children) {
            if (!child.isEmpty()) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Checks if this node is a leaf node (has no children).
     * 
     * @return true if this is a leaf node, false otherwise
     */
    public boolean isLeaf() {
        return children.isEmpty();
    }
    
    /**
     * Checks if this node is the root node (has no parent).
     * 
     * @return true if this is the root node, false otherwise
     */
    public boolean isRoot() {
        return parent == null;
    }
    
    /**
     * Gets the depth of this node in the tree (root = 0).
     * 
     * @return The depth of this node
     */
    public int getDepth() {
        int depth = 0;
        VulnerabilityNode current = parent;
        while (current != null) {
            depth++;
            current = current.getParent();
        }
        return depth;
    }
    
    /**
     * Gets the full path from root to this node.
     * 
     * @return The full path as a string (e.g., "192.168.1.100/HTTP/admin")
     */
    public String getFullPath() {
        if (parent == null) {
            return name;
        }
        
        StringBuilder path = new StringBuilder();
        List<String> pathComponents = new ArrayList<>();
        
        VulnerabilityNode current = this;
        while (current != null) {
            pathComponents.add(0, current.getName());
            current = current.getParent();
        }
        
        return String.join("/", pathComponents);
    }
    
    /**
     * Creates a formatted tree representation of this node and its children.
     * 
     * @param includeVulnerabilities Whether to include vulnerability details
     * @return A multi-line formatted tree string
     */
    public String formatTree(boolean includeVulnerabilities) {
        StringBuilder sb = new StringBuilder();
        formatTreeRecursive(sb, "", true, includeVulnerabilities);
        return sb.toString();
    }
    
    /**
     * Recursively formats the tree structure.
     * 
     * @param sb The StringBuilder to append to
     * @param prefix The current line prefix
     * @param isLast Whether this is the last child at this level
     * @param includeVulnerabilities Whether to include vulnerability details
     */
    private void formatTreeRecursive(StringBuilder sb, String prefix, boolean isLast, boolean includeVulnerabilities) {
        // Add this node
        sb.append(prefix);
        sb.append(isLast ? "└── " : "├── ");
        sb.append(getNodeIcon()).append(" ").append(name);
        
        int vulnCount = getTotalVulnerabilityCount();
        if (vulnCount > 0) {
            sb.append(" (").append(vulnCount).append(" vulnerabilities)");
        }
        sb.append("\n");
        
        // Add vulnerability details if requested
        if (includeVulnerabilities && !vulnerabilities.isEmpty()) {
            String childPrefix = prefix + (isLast ? "    " : "│   ");
            for (int i = 0; i < vulnerabilities.size(); i++) {
                Vulnerability vuln = vulnerabilities.get(i);
                boolean isLastVuln = (i == vulnerabilities.size() - 1) && children.isEmpty();
                
                sb.append(childPrefix);
                sb.append(isLastVuln ? "└── " : "├── ");
                sb.append(vuln.getSeverity().getIcon()).append(" ");
                sb.append(vuln.getName());
                if (vuln.getCveId() != null) {
                    sb.append(" (").append(vuln.getCveId()).append(")");
                }
                sb.append("\n");
            }
        }
        
        // Add child nodes
        String childPrefix = prefix + (isLast ? "    " : "│   ");
        for (int i = 0; i < children.size(); i++) {
            boolean isLastChild = (i == children.size() - 1);
            children.get(i).formatTreeRecursive(sb, childPrefix, isLastChild, includeVulnerabilities);
        }
    }
    
    /**
     * Gets an appropriate icon for this node type.
     * 
     * @return Unicode icon representing the node type
     */
    private String getNodeIcon() {
        switch (type) {
            case "TARGET": return "🎯";
            case "SERVICE": return "🔧";
            case "PATH": return "📁";
            case "VULNERABILITY": return "🔍";
            default: return "📄";
        }
    }
    
    @Override
    public String toString() {
        return String.format("VulnerabilityNode{name='%s', type='%s', children=%d, vulnerabilities=%d}", 
                           name, type, children.size(), vulnerabilities.size());
    }
}