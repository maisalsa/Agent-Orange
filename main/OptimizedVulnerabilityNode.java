package com.example;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Memory and performance optimized VulnerabilityNode for resource-constrained systems.
 * 
 * Key optimizations:
 * - Uses concurrent collections for thread safety
 * - Minimizes memory footprint through efficient data structures
 * - Provides fast lookup operations
 * - Uses string interning for memory efficiency
 * - Implements lazy initialization where appropriate
 * 
 * @author Agent-Orange Team
 * @version 2.0
 */
public class OptimizedVulnerabilityNode {
    
    // Core node properties (immutable after creation)
    private final String name;
    private final String type;
    
    // Mutable collections with thread safety
    private final Map<String, OptimizedVulnerabilityNode> children;
    private final List<Vulnerability> vulnerabilities;
    
    // Parent reference for tree navigation
    private volatile OptimizedVulnerabilityNode parent;
    
    // Performance optimization flags
    private static final int INITIAL_CHILDREN_CAPACITY = 8;
    private static final int INITIAL_VULNERABILITIES_CAPACITY = 4;
    
    /**
     * Constructs a new optimized VulnerabilityNode.
     * 
     * @param name The name of this node
     * @param type The type of this node (PROJECT, TARGET, SERVICE, PATH)
     * @throws IllegalArgumentException if name or type is null or empty
     */
    public OptimizedVulnerabilityNode(String name, String type) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Node name cannot be null or empty");
        }
        if (type == null || type.trim().isEmpty()) {
            throw new IllegalArgumentException("Node type cannot be null or empty");
        }
        
        this.name = name.trim().intern(); // Intern for memory efficiency
        this.type = type.trim().toUpperCase().intern();
        
        // Initialize thread-safe collections with appropriate initial capacities
        this.children = new ConcurrentHashMap<>(INITIAL_CHILDREN_CAPACITY);
        this.vulnerabilities = new CopyOnWriteArrayList<>(); // Good for read-heavy workloads
    }
    
    /**
     * Copy constructor for creating optimized node from legacy node.
     * 
     * @param legacyNode The original vulnerability node to optimize
     */
    public OptimizedVulnerabilityNode(VulnerabilityNode legacyNode) {
        this(legacyNode.getName(), legacyNode.getType());
        
        // Copy vulnerabilities
        legacyNode.getVulnerabilities().forEach(this::addVulnerability);
        
        // Copy children recursively
        for (VulnerabilityNode legacyChild : legacyNode.getChildren()) {
            OptimizedVulnerabilityNode optimizedChild = new OptimizedVulnerabilityNode(legacyChild);
            addChild(optimizedChild);
        }
    }
    
    /**
     * Adds a child node to this node.
     * 
     * @param child The child node to add
     * @throws IllegalArgumentException if child is null or has the same name as existing child
     */
    public void addChild(OptimizedVulnerabilityNode child) {
        if (child == null) {
            throw new IllegalArgumentException("Child node cannot be null");
        }
        
        String childName = child.getName();
        if (children.containsKey(childName)) {
            throw new IllegalArgumentException("Child with name '" + childName + "' already exists");
        }
        
        children.put(childName, child);
        child.parent = this;
    }
    
    /**
     * Removes a child node from this node.
     * 
     * @param child The child node to remove
     * @return true if the child was removed, false if it wasn't found
     */
    public boolean removeChild(OptimizedVulnerabilityNode child) {
        if (child == null) {
            return false;
        }
        
        OptimizedVulnerabilityNode removed = children.remove(child.getName());
        if (removed != null) {
            removed.parent = null;
            return true;
        }
        return false;
    }
    
    /**
     * Finds a child node by name.
     * 
     * @param childName The name of the child to find
     * @return The child node, or null if not found
     */
    public OptimizedVulnerabilityNode findChild(String childName) {
        if (childName == null) {
            return null;
        }
        return children.get(childName.intern());
    }
    
    /**
     * Finds or creates a child node with the specified name and type.
     * This method is optimized for scenarios where nodes are frequently accessed.
     * 
     * @param childName The name of the child
     * @param childType The type of the child
     * @return The existing or newly created child node
     */
    public OptimizedVulnerabilityNode findOrCreateChild(String childName, String childType) {
        if (childName == null || childName.trim().isEmpty()) {
            throw new IllegalArgumentException("Child name cannot be null or empty");
        }
        
        String internedName = childName.trim().intern();
        
        // Use computeIfAbsent for atomic find-or-create operation
        return children.computeIfAbsent(internedName, 
            name -> {
                OptimizedVulnerabilityNode newChild = new OptimizedVulnerabilityNode(name, childType);
                newChild.parent = this;
                return newChild;
            });
    }
    
    /**
     * Adds a vulnerability to this node.
     * 
     * @param vulnerability The vulnerability to add
     * @throws IllegalArgumentException if vulnerability is null
     */
    public void addVulnerability(Vulnerability vulnerability) {
        if (vulnerability == null) {
            throw new IllegalArgumentException("Vulnerability cannot be null");
        }
        
        vulnerabilities.add(vulnerability);
    }
    
    /**
     * Removes a vulnerability from this node.
     * 
     * @param vulnerability The vulnerability to remove
     * @return true if the vulnerability was removed, false if it wasn't found
     */
    public boolean removeVulnerability(Vulnerability vulnerability) {
        if (vulnerability == null) {
            return false;
        }
        
        return vulnerabilities.remove(vulnerability);
    }
    
    /**
     * Gets all vulnerabilities in this node.
     * Returns a copy to prevent external modification.
     * 
     * @return List of vulnerabilities (defensive copy)
     */
    public List<Vulnerability> getVulnerabilities() {
        return new ArrayList<>(vulnerabilities);
    }
    
    /**
     * Gets the vulnerabilities list directly for internal operations.
     * This method should only be used by trusted internal code.
     * 
     * @return Direct reference to vulnerabilities list
     */
    List<Vulnerability> getVulnerabilitiesInternal() {
        return vulnerabilities;
    }
    
    /**
     * Gets all child nodes.
     * Returns a copy to prevent external modification.
     * 
     * @return Collection of child nodes (defensive copy)
     */
    public Collection<OptimizedVulnerabilityNode> getChildren() {
        return new ArrayList<>(children.values());
    }
    
    /**
     * Gets a child node by name efficiently.
     * 
     * @param name The name of the child node
     * @return The child node, or null if not found
     */
    public OptimizedVulnerabilityNode getChild(String name) {
        if (name == null) {
            return null;
        }
        return children.get(name.intern());
    }
    
    /**
     * Gets all child names efficiently.
     * 
     * @return Set of child names
     */
    public Set<String> getChildNames() {
        return Collections.unmodifiableSet(children.keySet());
    }
    
    /**
     * Checks if this node has any children.
     * 
     * @return true if this node has children, false otherwise
     */
    public boolean hasChildren() {
        return !children.isEmpty();
    }
    
    /**
     * Checks if this node has any vulnerabilities.
     * 
     * @return true if this node has vulnerabilities, false otherwise
     */
    public boolean hasVulnerabilities() {
        return !vulnerabilities.isEmpty();
    }
    
    /**
     * Gets the total number of vulnerabilities in this node and all descendants.
     * 
     * @return Total vulnerability count
     */
    public int getTotalVulnerabilityCount() {
        int count = vulnerabilities.size();
        
        for (OptimizedVulnerabilityNode child : children.values()) {
            count += child.getTotalVulnerabilityCount();
        }
        
        return count;
    }
    
    /**
     * Gets the total number of child nodes (direct children only).
     * 
     * @return Number of direct children
     */
    public int getChildCount() {
        return children.size();
    }
    
    /**
     * Gets the depth of this node in the tree (root = 0).
     * 
     * @return Depth level
     */
    public int getDepth() {
        int depth = 0;
        OptimizedVulnerabilityNode current = this.parent;
        
        while (current != null) {
            depth++;
            current = current.parent;
        }
        
        return depth;
    }
    
    /**
     * Gets the path from root to this node.
     * 
     * @return List of node names from root to this node
     */
    public List<String> getPath() {
        List<String> path = new ArrayList<>();
        OptimizedVulnerabilityNode current = this;
        
        while (current != null) {
            path.add(0, current.name); // Add to beginning for correct order
            current = current.parent;
        }
        
        return path;
    }
    
    /**
     * Gets the path as a string with specified separator.
     * 
     * @param separator The separator to use between path elements
     * @return Path as a string
     */
    public String getPathString(String separator) {
        return String.join(separator != null ? separator : "/", getPath());
    }
    
    /**
     * Finds the root node of this tree.
     * 
     * @return The root node
     */
    public OptimizedVulnerabilityNode getRoot() {
        OptimizedVulnerabilityNode current = this;
        
        while (current.parent != null) {
            current = current.parent;
        }
        
        return current;
    }
    
    /**
     * Checks if this node is the root node.
     * 
     * @return true if this is the root node, false otherwise
     */
    public boolean isRoot() {
        return parent == null;
    }
    
    /**
     * Checks if this node is a leaf node (no children).
     * 
     * @return true if this is a leaf node, false otherwise
     */
    public boolean isLeaf() {
        return children.isEmpty();
    }
    
    /**
     * Collects all vulnerabilities from this node and all descendants.
     * 
     * @return List of all vulnerabilities in this subtree
     */
    public List<Vulnerability> getAllVulnerabilities() {
        List<Vulnerability> allVulnerabilities = new ArrayList<>();
        collectVulnerabilities(allVulnerabilities);
        return allVulnerabilities;
    }
    
    /**
     * Recursively collects vulnerabilities from this node and descendants.
     * 
     * @param collector The list to collect vulnerabilities into
     */
    private void collectVulnerabilities(List<Vulnerability> collector) {
        collector.addAll(vulnerabilities);
        
        for (OptimizedVulnerabilityNode child : children.values()) {
            child.collectVulnerabilities(collector);
        }
    }
    
    /**
     * Searches for vulnerabilities matching the specified criteria in this subtree.
     * 
     * @param searchTerm The term to search for
     * @param caseSensitive Whether the search should be case sensitive
     * @return List of matching vulnerabilities
     */
    public List<Vulnerability> searchVulnerabilities(String searchTerm, boolean caseSensitive) {
        if (searchTerm == null || searchTerm.trim().isEmpty()) {
            return Collections.emptyList();
        }
        
        List<Vulnerability> results = new ArrayList<>();
        String term = caseSensitive ? searchTerm.trim() : searchTerm.trim().toLowerCase();
        
        searchVulnerabilitiesRecursive(results, term, caseSensitive);
        
        return results;
    }
    
    /**
     * Recursively searches for vulnerabilities in this subtree.
     */
    private void searchVulnerabilitiesRecursive(List<Vulnerability> results, String term, boolean caseSensitive) {
        // Search vulnerabilities in this node
        for (Vulnerability vuln : vulnerabilities) {
            if (matchesSearchTerm(vuln, term, caseSensitive)) {
                results.add(vuln);
            }
        }
        
        // Search children
        for (OptimizedVulnerabilityNode child : children.values()) {
            child.searchVulnerabilitiesRecursive(results, term, caseSensitive);
        }
    }
    
    /**
     * Checks if a vulnerability matches the search term.
     */
    private boolean matchesSearchTerm(Vulnerability vuln, String term, boolean caseSensitive) {
        if (vuln == null) return false;
        
        // Check CVE ID
        if (vuln.getCveId() != null) {
            String cveId = caseSensitive ? vuln.getCveId() : vuln.getCveId().toLowerCase();
            if (cveId.contains(term)) return true;
        }
        
        // Check name
        if (vuln.getName() != null) {
            String name = caseSensitive ? vuln.getName() : vuln.getName().toLowerCase();
            if (name.contains(term)) return true;
        }
        
        // Check description
        if (vuln.getDescription() != null) {
            String desc = caseSensitive ? vuln.getDescription() : vuln.getDescription().toLowerCase();
            if (desc.contains(term)) return true;
        }
        
        return false;
    }
    
    /**
     * Gets memory usage statistics for this node.
     * 
     * @return Map containing memory usage information
     */
    public Map<String, Object> getMemoryStats() {
        Map<String, Object> stats = new HashMap<>();
        
        stats.put("childrenCount", children.size());
        stats.put("vulnerabilitiesCount", vulnerabilities.size());
        stats.put("totalVulnerabilities", getTotalVulnerabilityCount());
        stats.put("depth", getDepth());
        stats.put("isLeaf", isLeaf());
        stats.put("isRoot", isRoot());
        
        return stats;
    }
    
    /**
     * Optimizes memory usage for this node and all descendants.
     * Call this method during low-activity periods.
     */
    public void optimizeMemory() {
        // Optimize children recursively
        for (OptimizedVulnerabilityNode child : children.values()) {
            child.optimizeMemory();
        }
        
        // Remove empty children that have no vulnerabilities and no descendants
        children.entrySet().removeIf(entry -> {
            OptimizedVulnerabilityNode child = entry.getValue();
            return child.vulnerabilities.isEmpty() && child.children.isEmpty();
        });
    }
    
    /**
     * Creates a formatted string representation of this node and its subtree.
     * 
     * @return Formatted tree structure
     */
    public String getFormattedTree() {
        StringBuilder sb = new StringBuilder();
        buildFormattedTree(sb, "", true);
        return sb.toString();
    }
    
    /**
     * Recursively builds formatted tree representation.
     */
    private void buildFormattedTree(StringBuilder sb, String prefix, boolean isLast) {
        // Add this node
        sb.append(prefix);
        sb.append(isLast ? "└── " : "├── ");
        sb.append(name);
        sb.append(" [").append(type).append("]");
        sb.append(" (").append(vulnerabilities.size()).append(" vulns)");
        sb.append("\n");
        
        // Add children
        List<OptimizedVulnerabilityNode> childList = new ArrayList<>(children.values());
        for (int i = 0; i < childList.size(); i++) {
            boolean isChildLast = (i == childList.size() - 1);
            String childPrefix = prefix + (isLast ? "    " : "│   ");
            childList.get(i).buildFormattedTree(sb, childPrefix, isChildLast);
        }
    }
    
    // Getter methods
    public String getName() {
        return name;
    }
    
    public String getType() {
        return type;
    }
    
    public OptimizedVulnerabilityNode getParent() {
        return parent;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof OptimizedVulnerabilityNode)) return false;
        
        OptimizedVulnerabilityNode other = (OptimizedVulnerabilityNode) obj;
        return Objects.equals(name, other.name) && 
               Objects.equals(type, other.type) &&
               Objects.equals(parent, other.parent);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, type);
    }
    
    @Override
    public String toString() {
        return String.format("OptimizedVulnerabilityNode{name='%s', type='%s', children=%d, vulnerabilities=%d}", 
                           name, type, children.size(), vulnerabilities.size());
    }
}