package com.example;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Represents a single vulnerability discovered during a penetration test.
 * 
 * This class encapsulates all relevant information about a security finding,
 * including its severity, affected components, remediation steps, and metadata.
 * 
 * @author Agent-Orange Team
 * @version 1.0
 */
public class Vulnerability {
    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    
    private String id;
    private String name;
    private String description;
    private Severity severity;
    private String cveId;
    private String target;
    private String service;
    private String path;
    private String evidence;
    private List<String> remediation;
    private LocalDateTime discoveredAt;
    private String discoveredBy;
    private boolean verified;
    private String notes;
    
    /**
     * Constructs a new Vulnerability with required fields.
     * 
     * @param id Unique identifier for this vulnerability
     * @param name Short descriptive name
     * @param description Detailed description of the vulnerability
     * @param severity Severity level of the vulnerability
     * @param target The target system or component affected
     */
    public Vulnerability(String id, String name, String description, Severity severity, String target) {
        if (id == null || id.trim().isEmpty()) {
            throw new IllegalArgumentException("Vulnerability ID cannot be null or empty");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Vulnerability name cannot be null or empty");
        }
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Vulnerability description cannot be null or empty");
        }
        if (severity == null) {
            throw new IllegalArgumentException("Vulnerability severity cannot be null");
        }
        if (target == null || target.trim().isEmpty()) {
            throw new IllegalArgumentException("Vulnerability target cannot be null or empty");
        }
        
        this.id = id.trim();
        this.name = name.trim();
        this.description = description.trim();
        this.severity = severity;
        this.target = target.trim();
        this.remediation = new ArrayList<>();
        this.discoveredAt = LocalDateTime.now();
        this.verified = false;
    }
    
    /**
     * Creates a new Vulnerability with proper CVE naming conventions.
     * This factory method ensures that CVE IDs are properly validated and used
     * as the primary name when available.
     * 
     * @param id Unique identifier for this vulnerability
     * @param rawName Raw name/title of the vulnerability
     * @param description Detailed description of the vulnerability
     * @param severity Severity level of the vulnerability
     * @param target The target system or component affected
     * @param cveId Optional CVE ID (can be null)
     * @return A new Vulnerability with proper CVE naming conventions
     */
    public static Vulnerability createWithCveConvention(String id, String rawName, String description, 
                                                       Severity severity, String target, String cveId) {
        // Use CveUtils to determine proper naming
        CveUtils.VulnerabilityInfo vulnInfo = CveUtils.createVulnerabilityInfo(
            id, rawName, description, target, cveId);
        
        // Create the vulnerability with the determined name and description
        Vulnerability vulnerability = new Vulnerability(
            vulnInfo.getId(),
            vulnInfo.getName(),
            vulnInfo.getDescription() != null ? vulnInfo.getDescription() : description,
            severity,
            target
        );
        
        // Set the CVE ID if one was determined
        if (vulnInfo.hasCveId()) {
            vulnerability.setCveId(vulnInfo.getCveId());
        }
        
        return vulnerability;
    }
    
    /**
     * Creates a new Vulnerability from Burp Suite findings with CVE convention.
     * This method extracts potential CVE IDs from Burp Suite issue names and descriptions.
     * 
     * @param issueType Burp Suite issue type
     * @param issueName Burp Suite issue name
     * @param description Full description from Burp Suite
     * @param severity Mapped severity level
     * @param target The target host
     * @return A new Vulnerability with proper CVE naming
     */
    public static Vulnerability createFromBurpSuite(String issueType, String issueName, 
                                                   String description, Severity severity, String target) {
        return createWithCveConvention(
            "BURP_" + issueType,
            issueName,
            description,
            severity,
            target,
            null // Let CveUtils extract CVE ID from name/description
        );
    }
    
    /**
     * Gets the unique identifier for this vulnerability.
     * 
     * @return The vulnerability ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Sets the unique identifier for this vulnerability.
     * 
     * @param id The new vulnerability ID
     * @throws IllegalArgumentException if ID is null or empty
     */
    public void setId(String id) {
        if (id == null || id.trim().isEmpty()) {
            throw new IllegalArgumentException("Vulnerability ID cannot be null or empty");
        }
        this.id = id.trim();
    }
    
    /**
     * Gets the short descriptive name of this vulnerability.
     * 
     * @return The vulnerability name
     */
    public String getName() {
        return name;
    }
    
    /**
     * Sets the short descriptive name of this vulnerability.
     * 
     * @param name The new vulnerability name
     * @throws IllegalArgumentException if name is null or empty
     */
    public void setName(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Vulnerability name cannot be null or empty");
        }
        this.name = name.trim();
    }
    
    /**
     * Gets the detailed description of this vulnerability.
     * 
     * @return The vulnerability description
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Sets the detailed description of this vulnerability.
     * 
     * @param description The new vulnerability description
     * @throws IllegalArgumentException if description is null or empty
     */
    public void setDescription(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Vulnerability description cannot be null or empty");
        }
        this.description = description.trim();
    }
    
    /**
     * Gets the severity level of this vulnerability.
     * 
     * @return The vulnerability severity
     */
    public Severity getSeverity() {
        return severity;
    }
    
    /**
     * Sets the severity level of this vulnerability.
     * 
     * @param severity The new vulnerability severity
     * @throws IllegalArgumentException if severity is null
     */
    public void setSeverity(Severity severity) {
        if (severity == null) {
            throw new IllegalArgumentException("Vulnerability severity cannot be null");
        }
        this.severity = severity;
    }
    
    /**
     * Gets the CVE identifier if applicable.
     * 
     * @return The CVE ID or null if not applicable
     */
    public String getCveId() {
        return cveId;
    }
    
    /**
     * Sets the CVE identifier for this vulnerability.
     * The CVE ID will be validated and normalized to uppercase format.
     * 
     * @param cveId The CVE identifier (e.g., "CVE-2023-1234")
     * @throws IllegalArgumentException if the CVE ID format is invalid
     */
    public void setCveId(String cveId) {
        if (cveId == null || cveId.trim().isEmpty()) {
            this.cveId = null;
            return;
        }
        
        String normalized = CveUtils.normalizeCveId(cveId);
        if (normalized == null) {
            throw new IllegalArgumentException("Invalid CVE ID format: " + cveId + 
                                             ". Expected format: CVE-YYYY-NNNN");
        }
        
        this.cveId = normalized;
    }
    
    /**
     * Gets the target system or component affected by this vulnerability.
     * 
     * @return The target identifier
     */
    public String getTarget() {
        return target;
    }
    
    /**
     * Sets the target system or component affected by this vulnerability.
     * 
     * @param target The target identifier
     * @throws IllegalArgumentException if target is null or empty
     */
    public void setTarget(String target) {
        if (target == null || target.trim().isEmpty()) {
            throw new IllegalArgumentException("Vulnerability target cannot be null or empty");
        }
        this.target = target.trim();
    }
    
    /**
     * Gets the service affected by this vulnerability.
     * 
     * @return The service name or null if not applicable
     */
    public String getService() {
        return service;
    }
    
    /**
     * Sets the service affected by this vulnerability.
     * 
     * @param service The service name (e.g., "HTTP", "SSH", "MySQL")
     */
    public void setService(String service) {
        this.service = (service != null) ? service.trim() : null;
    }
    
    /**
     * Gets the specific path or location where this vulnerability was found.
     * 
     * @return The vulnerability path or null if not applicable
     */
    public String getPath() {
        return path;
    }
    
    /**
     * Sets the specific path or location where this vulnerability was found.
     * 
     * @param path The vulnerability path (e.g., "/admin/login", "/api/v1/users")
     */
    public void setPath(String path) {
        this.path = (path != null) ? path.trim() : null;
    }
    
    /**
     * Gets the evidence or proof-of-concept for this vulnerability.
     * 
     * @return The evidence text or null if not provided
     */
    public String getEvidence() {
        return evidence;
    }
    
    /**
     * Sets the evidence or proof-of-concept for this vulnerability.
     * 
     * @param evidence The evidence text, HTTP requests, screenshots, etc.
     */
    public void setEvidence(String evidence) {
        this.evidence = (evidence != null) ? evidence.trim() : null;
    }
    
    /**
     * Gets the list of remediation steps for this vulnerability.
     * 
     * @return A modifiable list of remediation steps
     */
    public List<String> getRemediation() {
        return remediation;
    }
    
    /**
     * Adds a remediation step to this vulnerability.
     * 
     * @param step The remediation step to add
     * @throws IllegalArgumentException if step is null or empty
     */
    public void addRemediationStep(String step) {
        if (step == null || step.trim().isEmpty()) {
            throw new IllegalArgumentException("Remediation step cannot be null or empty");
        }
        remediation.add(step.trim());
    }
    
    /**
     * Sets the complete list of remediation steps.
     * 
     * @param remediation The new list of remediation steps
     */
    public void setRemediation(List<String> remediation) {
        this.remediation = (remediation != null) ? new ArrayList<>(remediation) : new ArrayList<>();
    }
    
    /**
     * Gets the timestamp when this vulnerability was discovered.
     * 
     * @return The discovery timestamp
     */
    public LocalDateTime getDiscoveredAt() {
        return discoveredAt;
    }
    
    /**
     * Sets the timestamp when this vulnerability was discovered.
     * 
     * @param discoveredAt The discovery timestamp
     */
    public void setDiscoveredAt(LocalDateTime discoveredAt) {
        this.discoveredAt = discoveredAt;
    }
    
    /**
     * Gets the name or identifier of who discovered this vulnerability.
     * 
     * @return The discoverer name or null if not specified
     */
    public String getDiscoveredBy() {
        return discoveredBy;
    }
    
    /**
     * Sets the name or identifier of who discovered this vulnerability.
     * 
     * @param discoveredBy The discoverer name
     */
    public void setDiscoveredBy(String discoveredBy) {
        this.discoveredBy = (discoveredBy != null) ? discoveredBy.trim() : null;
    }
    
    /**
     * Checks if this vulnerability has been verified.
     * 
     * @return true if verified, false otherwise
     */
    public boolean isVerified() {
        return verified;
    }
    
    /**
     * Sets the verification status of this vulnerability.
     * 
     * @param verified true if verified, false otherwise
     */
    public void setVerified(boolean verified) {
        this.verified = verified;
    }
    
    /**
     * Gets additional notes or comments about this vulnerability.
     * 
     * @return The notes or null if none provided
     */
    public String getNotes() {
        return notes;
    }
    
    /**
     * Sets additional notes or comments about this vulnerability.
     * 
     * @param notes The notes text
     */
    public void setNotes(String notes) {
        this.notes = (notes != null) ? notes.trim() : null;
    }
    
    /**
     * Gets the full path identifier for this vulnerability.
     * Combines target, service, and path into a hierarchical identifier.
     * 
     * @return The full path (e.g., "192.168.1.100/HTTP/admin/login")
     */
    public String getFullPath() {
        StringBuilder pathBuilder = new StringBuilder(target);
        
        if (service != null && !service.isEmpty()) {
            pathBuilder.append("/").append(service);
        }
        
        if (path != null && !path.isEmpty()) {
            pathBuilder.append("/").append(path);
        }
        
        return pathBuilder.toString();
    }
    
    /**
     * Serializes this vulnerability to a string format for file persistence.
     * 
     * @return The serialized vulnerability data
     */
    public String serialize() {
        StringBuilder sb = new StringBuilder();
        sb.append("VULN_START\n");
        sb.append("id=").append(id).append("\n");
        sb.append("name=").append(name).append("\n");
        sb.append("description=").append(description.replace("\n", "\\n")).append("\n");
        sb.append("severity=").append(severity.name()).append("\n");
        sb.append("target=").append(target).append("\n");
        
        if (cveId != null) sb.append("cveId=").append(cveId).append("\n");
        if (service != null) sb.append("service=").append(service).append("\n");
        if (path != null) sb.append("path=").append(path).append("\n");
        if (evidence != null) sb.append("evidence=").append(evidence.replace("\n", "\\n")).append("\n");
        if (discoveredBy != null) sb.append("discoveredBy=").append(discoveredBy).append("\n");
        if (notes != null) sb.append("notes=").append(notes.replace("\n", "\\n")).append("\n");
        
        sb.append("verified=").append(verified).append("\n");
        sb.append("discoveredAt=").append(discoveredAt.format(DATE_FORMAT)).append("\n");
        
        if (!remediation.isEmpty()) {
            sb.append("remediation=");
            for (int i = 0; i < remediation.size(); i++) {
                if (i > 0) sb.append("||");
                sb.append(remediation.get(i).replace("\n", "\\n"));
            }
            sb.append("\n");
        }
        
        sb.append("VULN_END\n");
        return sb.toString();
    }
    
    /**
     * Creates a vulnerability from serialized string data.
     * 
     * @param data The serialized vulnerability data
     * @return The deserialized Vulnerability object
     * @throws IllegalArgumentException if the data format is invalid
     */
    public static Vulnerability deserialize(String data) {
        if (data == null || !data.contains("VULN_START") || !data.contains("VULN_END")) {
            throw new IllegalArgumentException("Invalid vulnerability data format");
        }
        
        String[] lines = data.split("\n");
        String id = null, name = null, description = null, target = null;
        Severity severity = null;
        String cveId = null, service = null, path = null, evidence = null;
        String discoveredBy = null, notes = null;
        boolean verified = false;
        LocalDateTime discoveredAt = LocalDateTime.now();
        List<String> remediation = new ArrayList<>();
        
        for (String line : lines) {
            if (line.trim().isEmpty() || line.equals("VULN_START") || line.equals("VULN_END")) {
                continue;
            }
            
            int equalPos = line.indexOf('=');
            if (equalPos == -1) continue;
            
            String key = line.substring(0, equalPos).trim();
            String value = line.substring(equalPos + 1).trim();
            
            switch (key) {
                case "id": id = value; break;
                case "name": name = value; break;
                case "description": description = value.replace("\\n", "\n"); break;
                case "severity": severity = Severity.valueOf(value); break;
                case "target": target = value; break;
                case "cveId": cveId = value; break;
                case "service": service = value; break;
                case "path": path = value; break;
                case "evidence": evidence = value.replace("\\n", "\n"); break;
                case "discoveredBy": discoveredBy = value; break;
                case "notes": notes = value.replace("\\n", "\n"); break;
                case "verified": verified = Boolean.parseBoolean(value); break;
                case "discoveredAt": 
                    try {
                        discoveredAt = LocalDateTime.parse(value, DATE_FORMAT);
                    } catch (Exception e) {
                        // Use current time if parsing fails
                        discoveredAt = LocalDateTime.now();
                    }
                    break;
                case "remediation":
                    if (!value.isEmpty()) {
                        String[] steps = value.split("\\|\\|");
                        for (String step : steps) {
                            remediation.add(step.replace("\\n", "\n"));
                        }
                    }
                    break;
            }
        }
        
        if (id == null || name == null || description == null || severity == null || target == null) {
            throw new IllegalArgumentException("Missing required vulnerability fields");
        }
        
        Vulnerability vuln = new Vulnerability(id, name, description, severity, target);
        vuln.setCveId(cveId);
        vuln.setService(service);
        vuln.setPath(path);
        vuln.setEvidence(evidence);
        vuln.setDiscoveredBy(discoveredBy);
        vuln.setNotes(notes);
        vuln.setVerified(verified);
        vuln.setDiscoveredAt(discoveredAt);
        vuln.setRemediation(remediation);
        
        return vuln;
    }
    
    /**
     * Creates a formatted summary of this vulnerability for display.
     * 
     * @return A multi-line formatted summary
     */
    public String getFormattedSummary() {
        StringBuilder sb = new StringBuilder();
        sb.append("🔍 ").append(severity.getFormattedName()).append(" - ").append(name).append("\n");
        sb.append("📍 Target: ").append(getFullPath()).append("\n");
        sb.append("📝 Description: ").append(description).append("\n");
        
        if (cveId != null) {
            sb.append("🆔 CVE: ").append(cveId).append("\n");
        }
        
        if (verified) {
            sb.append("✅ Status: Verified\n");
        } else {
            sb.append("⏳ Status: Unverified\n");
        }
        
        if (!remediation.isEmpty()) {
            sb.append("🔧 Remediation:\n");
            for (int i = 0; i < remediation.size(); i++) {
                sb.append("   ").append(i + 1).append(". ").append(remediation.get(i)).append("\n");
            }
        }
        
        return sb.toString();
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Vulnerability that = (Vulnerability) obj;
        return Objects.equals(id, that.id);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
    
    @Override
    public String toString() {
        return String.format("Vulnerability{id='%s', name='%s', severity=%s, target='%s'}", 
                           id, name, severity, target);
    }
}